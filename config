# Common configuration for checking out & building Gemini packages.

DATE=`date +%Y%m%d | tr A-Z a-z`

CVSROOT=":pserver:rtfuser@polaris.hi.gemini.edu:/usr/software/dev/cvsroot/girafcvsroot"
SVNROOT="http://chara.hi.gemini.edu/svn/DRSoftware"
WIKIPAGE="http://gdpsg.wikis-internal.gemini.edu/index.php/OPS-ServerConfigurationManagement"

SRCDIR="/rtfperm/ac_sources"
PKGDIR="/rtfperm/ac_packages"
WORKDIR="/rtfproc/ac_build"
AREXT="tar.gz"

mkdir -p "$WORKDIR" "$PKGDIR"

# Package tag to check out ("latest" if unspecified):
unset TAG
case "$tag" in
    internal|INTERNAL)
        tag="internal"
        ;;
    dev|DEV|development|DEVELOPMENT)
        tag="dev"
        TAG="DEVELOPMENT"  # (Gemini IRAF/Python inconsistency)
        ;;
    latest|LATEST|"")
        tag="latest"
        ;;
    public|PUBLIC)
        tag="public"
        ;;
    gsops|GSOPS)
        tag="gsops"
        ;;
    gnops|GNOPS)
        tag="gnops"
        ;;
    *)
        echo "Invalid Gemini package version/tag '$tag'" >&2
        exit 1
        ;;
esac
[ -z "$TAG" ] && TAG=`echo $tag | tr a-z A-Z`

# Construct version string from the tag & date:
version="${tag}_${DATE}"

# Make sure we have any dependencies specified by the calling script:
missing=""
for dep in $deps; do
    if ! command -v $dep > /dev/null; then
        missing="$missing  $dep"
    fi
done
if [ -n "$missing" ]; then
    echo "Whoops; you need to install the following commands:" >&2
    echo "  $missing" >&2
    exit 1
fi

export DATE CVSROOT SVNROOT WIKIPAGE TAG SRCDIR WORKDIR AREXT tag version


# A few functions shared by the other scripts:

copy_tarball() {  # copy_tarball root_name
    local pkgstr=$1
    echo -n "Copying tarball to local shared mount..."
    if [ -n "$SRCDIR" -a -w "$SRCDIR/" ]; then
        if cp -p ${pkgstr}.${AREXT} "$SRCDIR/"; then
            echo "done."
        else
            echo "failed."
            status=1
        fi
    else
        echo "cannot write to ${SRCDIR}." >&2
        status=1
    fi
}

checkout_victory() {  # checkout_victory status
    local status=$1
    if [ "$status" = "0" ]; then
            echo "Packaged source for $pkgstr; great success."
    else
            echo "Failed to package source for $pkgstr." >&2
    fi
    exit $status
}

get_platform() {  # get_platform
    local re="^[ \t]*platform[ \t]*:[ \t]*"
    platform=$(conda info 2> /dev/null |egrep "$re" \
               | sed -e "s|$re||" -e 's|[ \t]*$||')
    if [ -z "$platform" ]; then
        echo "Failed to determine platform from \"conda info\"" >&2
        return 1
    fi
}

get_local_deps() {  # get_local_deps recipe (returns local_deps)
    # Grep the "build:" section of a specified package's meta.yaml for any
    # dependencies with recipes defined under the current directory. Returns
    # only immediate dependencies of a single package.
    local_deps=""
    local all_deps=$(sed -ne '/^[ \t]*requirements:/,$p' "$1/meta.yaml" \
        |sed -ne '/^[ \t]*build:/,/^[ \t]*[^ \t][^ \t]*:/p')
    for f in `find * -type d`; do
        if echo "$all_deps" | egrep -q "^[ \t]*-[ \t]*$f([ \t]|$)"; then
            local_deps="${local_deps:+$local_deps }$f"
        fi
    done
}

get_local_pkgs() {  # get_local_pkgs recipes (returns local_pkgs)
    # For a given list of package recipes defined under the current directory,
    # recursively add any likewise-defined recipes they depend on. This just
    # seems easier than trying to hook into the conda.resolve logic.
    local args pkg recipe new_deps found
    if [ "$1" = "RECURSE" ]; then
        shift
    else
        local_pkgs=""  # start with empty list at top-level invocation
    fi
    for recipe in $@; do
        new_deps=""; first=1
        get_local_deps $recipe
        for pkg in $recipe $local_deps; do
            found=""
            for lpkg in $local_pkgs; do
                if [ "$lpkg" = "$pkg" ]; then
                    found=1
                    break
                fi
            done
            if [ -z "$found" ]; then
                local_pkgs="${local_pkgs:+$local_pkgs }$pkg"
                [ -z "$first" ] && new_deps="$new_deps $pkg"
            fi
            first=""
        done
        get_local_pkgs RECURSE $new_deps
    done
}

